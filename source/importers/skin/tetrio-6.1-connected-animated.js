export const name = 'TETR.IO v6.1.0 connected animated';
export const desc = 'A complex 1024x1024 gif or multiple images with 48px by 48px blocks (see wiki)';
export const extrainputs = ['delay'];

import { KEYS, Validator } from './util.js';
export function test(files) {
  if (files.length == 1 && files[0].type != 'image/gif')
    return false;

  return files.every(file => {
    return new Validator(file)
      .filename(KEYS.CONNECTED)
      .dimension(1024, 1024)
      .isAllowed();
  });
}

import splitgif from './converters/util/splitgif.js';
import { load as loadconnraster } from './tetrio-6.1-connected.js';
export async function load(files, storage, options) {
  if (files.length == 1 && files[0].type == 'image/gif')
    files = await splitgif(files[0], options);

  let canvas = window.document.createElement('canvas');
  canvas.width = 1024 * Math.min(16, files.length);
  canvas.height = 1024 * Math.ceil(files.length/16);
  let memUse = Math.floor((canvas.width * canvas.height * 4) / 1024**3 * 100) / 100;
  (options&&options.log||(()=>{}))(`Target size: ${canvas.width}x${canvas.height} (~${memUse} GiB)`);
  let ctx = canvas.getContext('2d');

  for (let i = 0; i < files.length; i++) {
    if (typeof global != 'undefined' && global.gc) global.gc();
    ctx.drawImage(files[i].image, i%16 * 1024, Math.floor(i/16) * 1024, 1024, 1024);
  }

  let frame = canvas.toDataURL('image/png');
  if (frame == "data:,") {
    throw new Error(
      "Final texture too large when assembling animated sprite sheet " +
      `(Expected size: ~${memUse} GiB). ` +
      "This is a memory cap imposed by Firefox and/or Chrome. " +
      "Imported TPSEs generated by standalone tools can support larger canvases, " +
      "so use a TPSE file if available."
    );
  }

  await loadconnraster([files[0]], storage); // non-animated fallback
  await storage.set({
    skinAnim: frame,
    skinAnimMeta: {
      frames: files.length,
      delay: options.delay || 30
    }
  });
}
